package com.qala.dimeji.satoshidice.service;

import com.google.common.util.concurrent.ListenableFuture;
import com.qala.dimeji.satoshidice.dto.request.StakeRequest;
import com.qala.dimeji.satoshidice.dto.response.ApiResponse;
import lombok.extern.slf4j.Slf4j;
import org.bitcoinj.core.Address;
import org.bitcoinj.core.Peer;
import org.bitcoinj.core.Sha256Hash;
import org.bitcoinj.core.Transaction;
import org.bitcoinj.params.RegTestParams;
import org.bitcoinj.params.TestNet3Params;
import org.bitcoinj.script.Script;
import org.bitcoinj.store.BlockStoreException;
import org.bitcoinj.wallet.UnreadableWalletException;
import org.bitcoinj.wallet.Wallet;
import org.bitcoinj.wallet.WalletTransaction;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.net.UnknownHostException;
import java.security.SecureRandom;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ExecutionException;

@Service
@Slf4j
public class GameServiceImpl implements GameService {

    @Autowired
    private Wallet wallet;

    @Autowired
    private Peer peer;

    private final Map<Integer, String> transactionHashMap = new HashMap<>();
    private int count = 0;

    @Override
    public ApiResponse generateAddressToPay(){
        Address address = wallet.freshReceiveAddress();
        System.out.println(wallet.getTransactionsByTime());
        System.out.println(wallet.getWatchedAddresses());
        System.out.println(wallet.toString());
        return new ApiResponse(String.format("Pls send the amount of bitcoin you want to stake to: %s", address.toString()), "success", 200);
    }

    @Override
    public ApiResponse stake(StakeRequest request) throws ExecutionException, InterruptedException {
        if (request.getNumberPicked() > 100 || request.getNumberPicked() < 1){
            throw new IllegalStateException("Number cannot be less than 1 or greater than 100");
        }
        Transaction tx = getTransaction(request.getTransactionHash());
        System.out.println(wallet.getWalletTransactions().toString());
        System.out.println(tx.toString());
        System.out.println(tx);
        if (isTransactionPresent(tx)) {
            if(transactionHashMap.containsValue(request.getTransactionHash())){
                throw new IllegalStateException("You want to fraud us right!!!");
            }
            transactionHashMap.putIfAbsent(++count, request.getTransactionHash());
            SecureRandom random = new SecureRandom();
            System.out.println("this is the number generated by the server");
            int number = 1 + random.nextInt(100);
            if (request.getNumberPicked() /*e.g 50*/ <= number /*e.g 52*/){ /*win*/
                return new ApiResponse(
                        "You have won, kindly wait for approximately 1hr to get you funded",
                        "success",
                        200
                );
            }else{
                return new ApiResponse(
                        "You have lose, kindly try your luck again",
                        "success",
                        200
                );
            }

        }
        throw new IllegalStateException("Invalid transaction hash");
    }

    private boolean isTransactionPresent(Transaction tx) {
        for (WalletTransaction transaction : wallet.getWalletTransactions()) {
            if(transaction.getTransaction().getTxId() == tx.getTxId()){
                return true;
            }
        }
        return false;
    }

    private Transaction getTransaction(String transactionHash) throws InterruptedException, ExecutionException {
        Sha256Hash txHash = Sha256Hash.wrap(transactionHash);
        ListenableFuture<Transaction> futtrx = peer.getPeerMempoolTransaction(txHash);
        System.out.println("Waiting for node to send us the requested transaction: " + txHash);

        return futtrx.get();
    }
}
